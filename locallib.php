<?phpfunction expand_regexp($myregexp) {    global $regexporiginal;    // JR 16 DEC 2011 add parentheses if necessary; still need to detect un-parenthesized pipe    $firstletter = substr($myregexp, 1);    $lastletter = substr($myregexp, -1);    if ( strstr($myregexp, '|') && $firstletter != '(' && $lastletter != ')') {        $myregexp = '('.$myregexp.')';    }    $regexporiginal=$myregexp;    // DEV il faudra peut etre revoir cette liste    $charlist = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';    // change [a-c] to [abc] NOTE: ^ metacharacter is not processed inside []        $pattern = '/\\[\w-\w\\]/'; // find [a-c] in $myregexp    while (preg_match($pattern, $myregexp, $matches, PREG_OFFSET_CAPTURE) ) {        $result = $matches[0][0];        $offset = $matches[0][1];        $stringleft = substr($myregexp, 0, $offset +1);            $stringright = substr($myregexp, $offset + strlen($result) -1);        $c1 = $result[1];        $c3 = $result[3];        $rs = '';        for ($c = strrpos($charlist, $c1); $c < strrpos($charlist, $c3) +1; $c++) {            $rs.= $charlist[$c];        }        $myregexp = $stringleft.$rs.$stringright;    }// provisionally replace existing escaped [] before processing the change [abc] to (a|b|c) JR 11-9-2007// see Oleg http://moodle.org/mod/forum/discuss.php?d=38542&parent=354095    while (strpos($myregexp, '\[')) {        $c1 = strpos($myregexp, '\[');        $c0 = $myregexp[$c1];        $myregexp = substr($myregexp, 0,$c1  ) .'¬' .substr($myregexp ,$c1 + 2);    }    while (strpos($myregexp, '\]')) {        $c1 = strpos($myregexp, '\]');        $c0 = $myregexp[$c1];        $myregexp = substr($myregexp, 0,$c1  ) .'¤' .substr($myregexp ,$c1 + 2);    }// change [abc] to (a|b|c)    $pattern =  '/\[.*?\]/'; // find [abc] in $myregexp    while (preg_match($pattern, $myregexp, $matches, PREG_OFFSET_CAPTURE) ) {        $result = $matches[0][0];        $offset = $matches[0][1];        $stringleft = substr($myregexp, 0, $offset);        $stringright = substr($myregexp, $offset + strlen($result));        $rs = substr($result, 1, strlen($result) -2);        $r = '';        for ($i=0; $i < strlen($rs); $i++) {            $r .= $rs[$i].'|';        }        $rs = '('.substr($r, 0, strlen($r)-1).')';        $myregexp = $stringleft.$rs.$stringright;    }// we can now safely restore the previously replaced escaped []    while (strpos($myregexp, '¬')) {        $c1 = strpos($myregexp, '¬');        $c0 = $myregexp[$c1];        $myregexp = substr($myregexp, 0,$c1  ) .'\[' .substr($myregexp ,$c1 + 2);    }    while (strpos($myregexp, '¤')) {        $c1 = strpos($myregexp, '¤');        $c0 = $myregexp[$c1];        $myregexp = substr($myregexp, 0,$c1  ) .'\]' .substr($myregexp ,$c1 + 2);    }// process ? in regexp (zero or one occurrence of preceding char)    while (strpos($myregexp, '?')) {        $c1 = strpos($myregexp, '?');        $c0 = $myregexp[$c1 - 1];//        if \? -> escaped ?, treat as literal char (replace with ¬ char temporarily)//        this ¬ char chosen because non-alphanumeric & rarely used...        if ($c0 == '\\') {            $myregexp = substr($myregexp, 0,$c1 -1 ) .'¬' .substr($myregexp ,$c1 + 1);            continue;        }//        if )? -> meta ? action upon parens (), replace with ¤ char temporarily//        this ¤ char chosen because non-alphanumeric & rarely used...        if ($c0 == ')') {            $myregexp = substr( $myregexp, 0, $c1 -1 ) .'¤' .substr($myregexp, $c1 + 1);            continue;        }    //        if ? metacharacter acts upon an escaped char, put it in $c2        if ($myregexp[$c1 - 2] == '\\') {            $c0 = '\\'.$c0;        }        $c2 = '('.$c0.'|)';        $myregexp = str_replace($c0.'?', $c2, $myregexp);    }    //    replaces possible temporary ¬ char with escaped question mark    if (strpos( $myregexp, '¬') != -1) {        $myregexp = str_replace('¬', '\?', $myregexp);    }    //    replaces possible temporary ¤ char with escaped question mark    if (strpos( $myregexp, '¤') != -1) {        $myregexp = str_replace('¤', ')?', $myregexp);    }    //    process ? metacharacter acting upon a set of parentheses \(.*?\)\?    $myregexp = str_replace(')?', '|)', $myregexp);    //    replace escaped characters with their escape code    while ($c = strpos($myregexp, '\\')) {        $s1 = substr($myregexp, $c, 2);        $s2 = $myregexp[$c + 1];        $s2 = rawurlencode($s2);    //        alaphanumeric chars can't be escaped; escape codes useful here are:    //        . = %2e    ; + = %2b ; * = %2a    //        add any others as needed & modify below accordingly        switch ($s2) {            case '.' : $s2 = '%2e'; break;            case '+' : $s2 = '%2b'; break;            case '*' : $s2 = '%2a'; break;        }        $myregexp = str_replace($s1, $s2, $myregexp);    }    //    remove starting and trailing metacharacters; not used for generation but useful for testing regexp    if (strpos($myregexp, '^')) {        $myregexp = substr($myregexp, 1);    }    if (strpos($myregexp, '$') == strlen($myregexp) -1) {        $myregexp = substr( $myregexp, 0, strlen($myregexp) -1);    }    $mynewregexp = find_nested_ors($myregexp); // check $myregexp for nested parentheses    if ($mynewregexp != null) {        $myregexp = $mynewregexp;    }    $result = find_ors($myregexp); // expand parenthesis contents    if ( is_array($result) ) {        $results = implode('\n', $result);    }    return $result; // returns array of alternate strings}// find individual $nestedors expressions in $myregexpfunction is_nested_ors ($mystring) {//return false;    $orsstart = 0; $orsend = 0; $isnested = false; $parens = 0; $result = '';    for ($i = 0; $i < strlen($mystring); $i++) {        switch ($mystring[$i]) {        case '(':            $parens++;            if ($parens == 1) {                $orsstart = $i;            }            if ($parens == 2) {                $isnested = true;            }            break;        case ')':            $parens--;            if ($parens == 0) {                if ($isnested == true) {                    $orsend = $i + 1;                    $i = strlen($mystring);                    break;                } //end if            } //end case        } //end switch    } // end for    if ($isnested == true) {        $result = substr( $mystring, $orsstart, $orsend - $orsstart);        return $result;    }    return false;}// find nested parenthesesfunction is_parents ($myregexp) {    $finalresult = null;    $pattern = '/[^(|)]*\\(([^(|)]*\\|[^(|)]*)+\\)[^(|)]*/';    if (preg_match_all($pattern, $myregexp, $matches, PREG_OFFSET_CAPTURE)) {    $matches = $matches[0];        for ($i=0; $i<sizeof($matches); $i++) {            $thisresult = $matches[$i][0];            $leftchar = $thisresult[0];            $rightchar = $thisresult[strlen($thisresult) -1];            $outerchars = $leftchar .$rightchar;            if ($outerchars !== '()') {                $finalresult = $thisresult;                break;            }        } // end for    } // end if    return $finalresult;}// find ((a|b)c)function find_nested_ors ($myregexp) {// find next nested parentheses in $myregexp    while ($nestedors = is_nested_ors ($myregexp)) {        $nestedorsoriginal = $nestedors;// find what?        while ($myparent = is_parents ($nestedors)) {            $leftchar = $nestedors[strpos($nestedors, $myparent) - 1];            $rightchar = $nestedors[strpos($nestedors, $myparent) + strlen($myparent)];            $outerchars = $leftchar.$rightchar;// il ne faut sans doute pas faire de BREAK ici...            if ($outerchars == ')(') {//                break;            }            switch ($outerchars) {                case '||':                case '()':                    $leftpar = '';                    $rightpar = '';                    break;                case '((':                case '))':                case '(|':                case '|(':                case ')|':                case '|)':                    $leftpar = '('; $rightpar = ')';                    break;                default:                    break;            }            $t1 = find_ors ($myparent);            $t = implode('|', $t1);            $myresult = $leftpar.$t.$rightpar;            $nestedors = str_replace( $myparent, $myresult, $nestedors);        }//    detect sequence of ((*|*)|(*|*)) within parentheses or |) or (| and remove all INSIDE parentheses        $pattern = '/(\\(|\\|)\\([^(|)]*\\|[^(|)]*\\)(\\|\\([^(|)]*\\|[^(|)]*\\))*(\\)|\\|)/';        while (preg_match($pattern, $nestedors, $matches, PREG_OFFSET_CAPTURE)) {            $plainors = $matches[0][0];            $leftchar = $plainors[0];            $rightchar = $plainors[strlen($plainors) -1];            $plainors2 = substr($plainors, 1, strlen($plainors) -2); // remove leading & trailing chars            $plainors2 = str_replace(  '(',  '', $plainors2);            $plainors2 = str_replace(  ')',  '', $plainors2);            $plainors2 = $leftchar .$plainors2 .$rightchar;            $nestedors = str_replace(  $plainors,  $plainors2, $nestedors);            if (is_parents($nestedors)) {                $myregexp = str_replace( $nestedorsoriginal, $nestedors, $myregexp);                continue;            }        }//        any sequence of (|)(|) in $nestedors? process them all        $pattern = '/(\\([^(]*?\\|*?\\)){2,99}/';        while (preg_match($pattern, $nestedors, $matches, PREG_OFFSET_CAPTURE)) {            $parensseq = $matches[0][0];            $myresult = find_ors ($parensseq);            $myresult = implode('|', $myresult);            $nestedors = str_replace( $parensseq, $myresult, $nestedors);        }// test if we have reached the singleOrs stage        if (is_parents ($nestedors) != null) {            $myregexp = str_replace( $nestedorsoriginal, $nestedors, $myregexp);            continue;        }// no parents left in $nestedors, ...// find all single (*|*|*|*) and remove parentheses        $patternsingleors = '/\\([^()]*\\)/';        $patternsingleorstotal = '/^\\([^()]*\\)$/';        while ($p = preg_match($patternsingleors, $nestedors, $matches, PREG_OFFSET_CAPTURE)) {            $r = preg_match($patternsingleorstotal, $nestedors, $matches, PREG_OFFSET_CAPTURE);            if ($r) {                if ($matches[0][0] == $nestedors) {                    break;                } // we have reached top of $nestedors: keep ( )!            }            $r = preg_match($patternsingleors, $nestedors, $matches, PREG_OFFSET_CAPTURE);            $singleparens = $matches[0][0];            $myresult = substr($singleparens, 1, strlen($singleparens)-2);            $nestedors = str_replace( $singleparens, $myresult, $nestedors);            if (is_parents ($nestedors) != null) {                $myregexp = str_replace( $nestedorsoriginal, $nestedors, $myregexp);                continue;            }        }        $myregexp = str_replace( $nestedorsoriginal, $nestedors, $myregexp);    } // end while ($nestedors = is_nested_ors ($myregexp))    return $myregexp;}function find_ors ($mystring) {    global $regexporiginal;//    add extra space between consecutive parentheses (that extra space will be removed later on)    $pattern = '/\\(.*?\\|.*?\\)/';    while (strpos($mystring, ')(')) {        $mystring = str_replace( ')(', ')µ(', $mystring);    }    if (strpos($mystring, ')(')) {        $mystring = str_replace( ')(', ')£(', $mystring);    }//    in $mystring, find the parts outside of parentheses ($plainparts)    $plainparts = preg_split($pattern, $mystring);        if ($plainparts) {            $plainparts = index_plain_parts ($mystring, $plainparts);        }    $a = preg_match_all($pattern, $mystring, $matches, PREG_OFFSET_CAPTURE);        if(!$a) {            $regexporiginal = stripslashes($regexporiginal);            return $regexporiginal;        }    $plainors = index_ors($mystring, $matches);//    send $list of $plainparts and $plainors to expand_ors () function    return(expand_ors ($plainparts, $plainors));}function expand_ors ($plainparts, $plainors) {//return;//    this function expands a chunk of words containing a single set of parenthesized alternatives//    of the type: <(aaa|bbb)> OR <ccc (aaa|bbb)> OR <ccc (aaa|bbb) ddd> etc.//    into a LIST of possible alternatives,//    e.g. <ccc (aaa|bbb|)> -> <ccc aaa>, <ccc bbb>, <ccc>    $expandedors = array();    $expandedors[] = '';    $slen = sizeof($expandedors);    $expandedors[$slen-1] = '';    // condition isset($plainparts[0]) added 14 SEP 2011    if (isset($plainparts[0]) && $plainparts[0] == 0) { // if chunk begins with $plainparts        $expandedors[$slen-1] = $plainparts[1];        array_splice($plainparts, 0,2);    }    while ((sizeof($plainparts) !=0) || (sizeof($plainors) !=0)) { // go through sentence $plainparts        $l = sizeof($expandedors);        for ($k=0; $k<$l; $k++) {            for ($m=0; $m < sizeof($plainors[1]); $m++) {                $expandedors[] = '';                $slen = sizeof($expandedors) -1;                $expandedors[$slen] = $expandedors[0].$plainors[1][$m];                if (sizeof($plainparts)) {                    if ($plainparts[1]) {                        $expandedors[$slen] .=$plainparts[1];                    }                }                $expandedors[$slen] = rawurldecode($expandedors[$slen]);            }        array_splice($expandedors, 0, 1);// remove current "model" sentence from Sentences        }        array_splice($plainors,0,2); // remove current $plainors        array_splice($plainparts,0,2); // remove current $plainparts    }//    eliminate all extra µ signs which have been placed to replace consecutive parentheses by )µ(        $n = count ($expandedors);        for ($i = 0; $i < $n; $i++) {            if (is_int(strpos($expandedors[$i], 'µ') ) ) { //corrects strpos for 1st char of a string found!                $expandedors[$i] = str_replace('µ', '', $expandedors[$i]);            }        }    return ($expandedors);}function index_plain_parts($mystring, $plainparts) {    $indexedplainparts = array();    if (is_array($plainparts) ) {        foreach($plainparts as $parts) {            if ($parts) {                $index = strpos($mystring, $parts) ;                $indexedplainparts[] = $index;                $indexedplainparts[] = $parts;            }        }    }    return ($indexedplainparts);}function index_ors($mystring, $plainors) {    $indexedplainors = array();    foreach ($plainors as $ors) {        foreach ($ors as $or) {            $indexedplainors[] = $or[1];            $o = substr($or[0], 1, strlen($or[0]) -2);            $o = explode('|', $o);            $indexedplainors[] = $o;        }    }    return ($indexedplainors);}// functions adapted from Hot Potatoesfunction check_beginning( $guess, $answer, $ignorecase){    /// Use text services    $textlib = textlib_get_instance();    $outstring = '';    if ($ignorecase) {        $guessoriginal = $guess;        $guess = strtoupper($guess);        $answer = strtoupper($answer);    }    $i1 = $textlib->strlen($guess);    $i2 = $textlib->strlen($answer);    for ($i=0; ( $i< $i1 && $i< $i2) ; $i++) {        if (strlen($answer) < $i ) {            break;        }        if ($textlib->substr($guess, $i, 1) == $textlib->substr($answer,$i , 1)) {            $outstring .= $textlib->substr($guess, $i, 1);        } else {            break;        }    }    if ($ignorecase) {        $outstring = $textlib->substr($guessoriginal,0,$textlib->strlen($outstring));    }    return $outstring;}function get_closest( $guess, $answers, $ignorecase, $ishint){    /// Use text services    $textlib = textlib_get_instance();    $closest[0] = ''; // closest answer to be displayed as input field value    $closest[1] = ''; // closest answer to be displayed in feedback line    $closest[2] = ''; // hint state :: plus (added 1 letter), minus (removed extra chars & added 1 letter),        //complete (correct response achieved), nil (beginning of sentence)    $closest[3] = ''; // student's guess (rest of)    $closest[4] = ''; // added letter or word (according to Help mode)    $closesta = '';    $l = $textlib->strlen($guess);    //$ishint = $hintadded;    if ($ishint) {        $closest[2] = 'nil';    }    $rightbits = array();    foreach ( $answers as $answer) {        $rightbits[0][] = $answer;        $rightbits[1][] = check_beginning($guess, $answer, $ignorecase, $ishint);    }    $s = sizeof($rightbits);    $longest = 0;    if ($s) {        $a = $rightbits[0];        $s = sizeof($a);        for ($i=0; $i<$s ;$i++) {            $a = $rightbits[0][$i];            $g = $rightbits[1][$i];            if ($textlib->strlen($g) > $longest) {                $longest = $textlib->strlen($g);                $closesta = $g;                if ($ishint) {                    $closest[2] = 'plus';                    $closesta_hint = $closesta;                    $closesta_hint .= $textlib->substr($a,$longest, 1);                    $lenguess = $textlib->strlen($guess);                    $lenclosesta_hint = $textlib->strlen($closesta_hint) - 1;                    if ($lenguess > $lenclosesta_hint) {                        $closest[2] = 'minus';                    }                    if ($textlib->substr($a,$longest, 1) == ' ') { // if hint letter is a space, add next one                        $closesta_hint .= $textlib->substr($a,$longest + 1, 1);                    }                    // word help ADDED JR 18 DEC 2011                    if ($ishint > 1) {                        if (preg_match('/\s.*/', $a, $matches, PREG_OFFSET_CAPTURE, strlen($g) + 1) ) {                            $closesta_hint = substr($a, 0, $matches[0][1]);                        } else {                            $closesta_hint = $a;                        }                    }                    if ( preg_match('/^'.$a.'$/'.$ignorecase, $closesta_hint)) {                        $closest[2] = 'complete'; // hint gives a complete correct answer                        $state->raw_grade = 0;                        break;                    }                }            }        }    }    $closest[0] = $closesta;    // type of hint state    switch ($closest[2]) {        case 'plus':/// TODO            $closest[0] = $closesta_hint;            $closest[1] = $guess;            $closest[4] = str_replace($guess, "", $closesta_hint);            break;        case 'minus':            $closest[0] = $closesta_hint;            $closest[1] = $closesta;            break;        case 'complete':            $closest[0] = $a;            $closest[1] = $a;            break;        default:            $closest[0] = $closesta;            $closest[1] = $closest[0];    }    /// search for correct *words* in student's guess, after closest answer has been found    if ($closest[0] != '' && $closest[2] != 'complete') {        $nbanswers = count ($answers);        $lenclosesta = strlen($closest[0]);        $minus = 0;        if ($closest[2] == 'minus') {            $minus = 1;        }        $restofanswer = substr($guess, $lenclosesta - $minus);        $restofanswers = '';        for ($i=0;$i<count ($answers);$i++) {            if ($rightbits[1]["$i"] != '') {                $rightbits0 = $rightbits[0]["$i"];                $rightbits1 = $rightbits[1]["$i"];                if ($rightbits1 == $closest[1]) {                    $restofanswers.= substr($rightbits[0]["$i"], $lenclosesta - $minus).' |';                }            }        }        if ($restofanswer) {            $wordsinrestofanswer = split(' ', $restofanswer);            $i = 0;            unset($array1, $array1);            $array1 = preg_split("/[\s,]+/", $restofanswer);            $array2 = preg_split("/[\s,]+/", $restofanswers);            $misplacedwords = array_intersect($array1, $array2);            $wrongwords = array_diff($array1, $array2);            foreach ($wrongwords as $key => $value) {                $wrongwords[$key] = '<span class="wrongword">'.$value.'</span>';            }            unset ($result);            $result =  $misplacedwords + $wrongwords;            ksort($result);            $result = implode (" | ", $result);            $guess = '<span class="misplacedword">'.$result.'</span>';            $closest[3] = $guess;            unset ($result);        }    }    return $closest;}// end of functions adapted from Hot Potatoes// function to find whether student's response matches at least the beginning of one of the correct answersfunction find_closest($question, $currentanswer, $correct_response=false, $hintadded = false) {    global $CFG;    /// Use text services    $textlib = textlib_get_instance();    // JR dec 2011 moved get alternate answers to new function    $alternateanswers = get_alternateanswers($question);    $alternatecorrectanswers = array();    // JR jan 2012 changed contents of alternateanswers    if (isset($question->id)) {        $qid = $question->id;        if (!isset ($SESSION->qtype_regexp_question->alternatecorrectanswers[$qid])) {            foreach($alternateanswers as $key => $alternateanswer) {                foreach($alternateanswer['answers'] as $alternate) {                    $alternatecorrectanswers[] = $alternate;                }            }            $SESSION->qtype_regexp_question->alternatecorrectanswers[$qid] = $alternatecorrectanswers;        }    }    // testing ignorecase    $ignorecase = 'i';    if ($question->usecase) {        $ignorecase = '';    };    // only use ishint value if hint button has been clicked    $ishint = $question->usehint * $hintadded;    // find closest answer matching student response    if (!isset($currentanswer) && !$correct_response) {        return null;    }    if ($correct_response) {        return $alternatecorrectanswers;    }    $closest = get_closest( $currentanswer, $alternatecorrectanswers, $ignorecase, $ishint);    if ($closest[2] == 'complete') {        return $closest;    }    // give first character of firstcorrectanswer to student (if option usehint for this question)    // TODO JR maybe not?    /*if ($closest[0] == '' && ($question->usehint == true) && $closest[2] == 'nil' ) {        $closest[0] = $textlib->substr($firstcorrectanswer, 0, 1);    }*/    return $closest;}// remove extra blank spaces from student's responsefunction remove_blanks($text) {    $pattern = "/  /"; // finds 2 successive spaces (note: \s does not work with French 'à' character!    while($w = preg_match($pattern, $text, $matches, PREG_OFFSET_CAPTURE) ) {        $text = substr($text, 0, $matches[0][1]) .substr($text ,$matches[0][1] + 1);    }    return $text;}// check that parentheses and square brackets are balanced, including nested onesfunction check_my_parens($myregexp, $markedline) {    $parens = array();    $sqbrackets = array();    // walk the $myregexp string to find parentheses and square brackets    for ($i = 0; $i<strlen($myregexp); $i++) {        $escaped = false;        if ($i > 0 && $myregexp[$i - 1] == "\\") {            $escaped = true;        }        if (!$escaped) {            switch ($myregexp[$i]) {                case '(': $parens[$i] = 'open'; break;                case ')': $parens[$i] = 'close'; break;                case '[': $sqbrackets[$i] = 'open'; break;                case ']': $sqbrackets[$i] = 'close'; break;                default: break;            }        }    }    // check for parentheses    $tags['open'] = '(';    $tags['close'] = ')';    $markedline2 = check_balanced($parens, $tags, $markedline);    // check for square brackets    $tags['open'] = '[';    $tags['close'] = ']';    $markedline2 = check_balanced($sqbrackets, $tags, $markedline2);    if ($markedline2 != $markedline) {        return $markedline2;    } else {        return;    }}    function check_balanced ($bracketstype, $tags, $markedline) {        $open = array();        foreach($bracketstype as $key=>$value) {            switch ($value) {                case 'open':                    $open[] = $key;                    break;                case 'close':                    if ($open) {                        $index = array_pop ($open);                        $bracketstype[$index] = null;                        $bracketstype[$key] = null;                    }                    break;            }        }        foreach($bracketstype as $key=>$value) {            if ($value) {                if($value == 'open') {                    $mark = $tags['open'];                }                if($value == 'close') {                    $mark = $tags['close'];                }                $markedline[$key] = $mark ;            }        }        return $markedline;    }function check_unescaped_metachars ($myregexp, $markedline) {    /// Joseph Rezeau 02 SEPTEMBER 2011    /// function to detect un-escaped metacharacters    /* full list of metacharacters used in regular expressions syntax    ALL these characters can be used as metacharacters in INCORRECT Answers (grade = None)    . ^ $ * ( ) [ ] + ? | { } \    characters which can NOT be used as metacharacters in an accepted Answer (grade > 0) and MUST be escaped if used for their LITERAL value:    . ^ $ * + { } \    characters which CAN be used as metacharacters in an accepted Answer (grade > 0) and must be escaped IF used for their LITERAL value:    use of those characters must lead to alternative CORRECT answers    ( ) [ ] | ?    */    $markedline2 = $markedline;    // all metacharacters must be escaped    // check for unescaped metacharacters, except for backslash itself    $unescaped_regex = '/(?<!\\\\)[\.\^\$\*\+\{\}]/';    // 1 (?<!\\\\) NO backslash preceding (this is a negative lookahead assertion)    // 2 [\.\^\$\*\+\{\}] list of metacharacters which can NOT be used in context of accepted Answer (grade > 0)    $unescaped_metachars = preg_match_all($unescaped_regex, $myregexp, $matches, PREG_OFFSET_CAPTURE);    if ($unescaped_metachars) {        foreach ($matches as $v1) {            // in marked line, replace blank spaces with the unescaped metacharacter            foreach ($v1 as $v2) {                $markedline2[$v2[1]] = $v2[0] ;            }        }    }    // now check for unescaped backslashes    $unescaped_regex = '/(^|[^\\\])\\\[^\.|\*|\(|\\[\]\{\}\/)\+\?\^\|\$\.]/';    // 1 (^|[^\\\]) = beginning of sentence OR no backslash    // 2 \\\ = followed by backslash    // 3 [^\.|\*|\(|\\[\]\{\}\/)\+\?\^\|\$\.] = NOT followed by a metacharacter    $unescaped_metachars = preg_match_all($unescaped_regex, $myregexp, $matches, PREG_OFFSET_CAPTURE);    if ($unescaped_metachars) {        $foundbackslash = substr($matches[0][0][0], 1, 3);        // we must skip a valid escaped backslash        if ($foundbackslash != "\\\\") {            foreach ($matches as $v1) {            // in marked line, replace blank spaces with the unescaped backslash \                foreach ($v1 as $v2) {                    $markedline2[$v2[1] + 1] = '\\' ;                }            }        }    }    if ($markedline2 != $markedline) {        return $markedline2;    } else {        return;    }}    // when displaying unescaped_metachars or unbalanced brackets, too long strings need to be cut up into chunks    // change $maxlen if necessary (e.g. to fit smaller width screens)    function splitstring ($longstring, $maxlen=75) {        /// Use text services        $textlib = textlib_get_instance();        $len = $textlib->strlen($longstring);        $stringchunks = array();        if ($len < $maxlen) {            $stringchunks [] = $longstring;        } else {            for ($i=0;$i<$len;$i += $maxlen) {                $stringchunks [] = $textlib->substr($longstring, $i, $maxlen);            }        }        return $stringchunks;    }function get_alternateanswers($question) {    global $CFG, $SESSION;    $qid = '';    if (isset($question->id)) {        $qid = $question->id;        if (isset ($SESSION->qtype_regexp_question->alternateanswers[$qid])) {            return $SESSION->qtype_regexp_question->alternateanswers[$qid];        }    }    $alternateanswers = array();    $i = 1;    foreach ($question->answers as $answer) {        if ($answer->fraction != 0) {            if ($i == 1) {                $firstcorrectanswer = $answer->answer;            }            $r = expand_regexp($answer->answer);            if ($r) {                $alternateanswers[$i]['fraction'] = ($answer->fraction*100).'%';                $alternateanswers[$i]['regexp'] = $answer->answer;                if (is_array($r)) {                    $alternateanswers[$i]['answers'] = $r; // normal alternateanswers (expanded)                } else {                    $alternateanswers[$i]['answers'][] = $r; // regexp was not expanded                }            }        }        $i++;    }    // store alternate answers in SESSION for caching effect DEC 2011    $SESSION->qtype_regexp_question->alternateanswers[$qid] = $alternateanswers;    $SESSION->qtype_regexp_question->alternatecorrectanswers[$qid] = '';    return $alternateanswers;}?>